use org.openflexo.foundation.fml.rt.FMLRTVirtualModelInstanceModelSlot as FMLRT;

import java.util.Date;
import java.lang.String;

@URI("http://www.openflexo.org/MULTIProcessChallenge/MetaModel.fml")
@Version("0.1")
public model MetaModel {
	
	/**
	 * A generic modeling element: support for a name and lastUpdated
	 */
	public abstract concept ModelingElement {
		String name;
		Date lastUpdated;

		create(String name) {
			name = parameters.name;
			this.update();
		}
		
		delete() {
		}
		
		public void update() {
			lastUpdated = new Date();
		}
	}

	/** 
	 *  A Type concept
	 */
	public concept Type extends ModelingElement {

		create(String name) {
			super(parameters.name);
		}

		delete() {
		}
	}

	/**
	 * Represents a process definition, as a collection of TaskTypes linked using gateways
	 */
	public concept ProcessType extends Type {
		TaskType[0,*] taskTypes with ConceptInstance(virtualModelInstance=container);
		Gateway[0,*] gateways with ConceptInstance(virtualModelInstance=container);
		Begin initialTaskType with ConceptInstance(virtualModelInstance=container);
		End[0,*] finalTaskTypes with ConceptInstance(virtualModelInstance=container);

		List<Sequencing> sequencingList  {
			List<Sequencing> get() {
				return select Sequencing from this;
			}
		};

		List<AndSplit> andSplitList  {
			List<AndSplit> get() {
				return select AndSplit from this;
			}
		};
		
		List<AndJoin> andJoinList  {
			List<AndJoin> get() {
				return select AndJoin from this;
			}
		};

		create(String name) {
			super(parameters.name);
		}
		
		delete() {
		}
		
		void addToTaskTypes(required TaskType taskType) {
			taskTypes.add(parameters.taskType);
		}
		
		void setInitialTaskType(required Begin beginTaskType) {
			initialTaskType = parameters.beginTaskType;
		}
		
		void addToFinalTaskTypes(required End endTaskType) {
			finalTaskTypes.add(parameters.endTaskType);
		}
		
		void addToGateways(required Gateway gateway) {
			gateways.add(parameters.gateway);
		}

		void removeFromGateways(required Gateway gateway) {
			gateways.remove(parameters.gateway);
		}
		
		void removeFromTaskTypes(required Gateway taskType) {
			taskTypes.remove(parameters.taskType);
		}
		
		void removeFromFinalTaskTypes(required Gateway taskType) {
			finalTaskTypes.remove(parameters.taskType);
		}

		/**
		 * Return from supplied Process the Task having supplied TaskType
		 */
		Task getTask(required TaskType taskType, Process process) {
			return select unique Task from parameters.process where (selected.type == parameters.taskType);
		}

		/**
		 * Instantiate a new Process with this ProcessType
		 */
		public Process newProcess(required String name) {
			Process returned = new Process(parameters.name,this);
			for (TaskType taskType : taskTypes) {
				log "Creating new Task for " + taskType;
				Task newTask = taskType.newTask(returned.name + "-" + taskType.name,returned);
				log "Created new Task for " + taskType + " --> " + newTask;
				if (taskType == initialTaskType) {
					returned.initialTask = newTask;
				}
			}
			return returned;
		}

		/**
		 * Represents a Task definition in a ProcessType
		 */
		public concept TaskType extends Type {
			
			Actor creator with ConceptInstance();
			ActorType[0,*] allowedActorTypes with ConceptInstance(virtualModelInstance=container.container);
			Actor[0,*] allowedActors with ConceptInstance(virtualModelInstance=container.container);
			ArtifactType[0,*] usedArtifactTypes with ConceptInstance(virtualModelInstance=container.container);
			ArtifactType[0,*] producedArtifactTypes with ConceptInstance(virtualModelInstance=container.container);
			int expectedDuration;
			boolean isCritical;
			
			create(String name) {
				super(parameters.name);
				isCritical = false;
			}
			
			delete() {
				if (container != null) {
					container.taskTypes.remove(this);
				}
			}
			
			public boolean addAllowedActorType(required ActorType actorType) {
				if (this.isValidActorType(parameters.actorType)) {
					allowedActorTypes.add(parameters.actorType);
					this.update();
					return true;
				}
				else {
					return false;
				}
			}
			
			public boolean addAllowedActor(required Actor actor) {
				if (this.isValidActor(parameters.actor)) {
					allowedActors.add(parameters.actor);
					this.update();
					return true;
				}
				else {
					return false;
				}
			}
			
			public boolean addUsedArtifactType(required ArtifactType artifactType) {
				if (this.isValidUsedArtifactType(parameters.artifactType)) {
					usedArtifactTypes.add(parameters.artifactType);
					this.update();
					return true;
				}
				else {
					return false;
				}
			}
			
			public boolean addProducedArtifactType(required ArtifactType artifactType) {
				if (this.isValidProducedArtifactType(parameters.artifactType)) {
					producedArtifactTypes.add(parameters.artifactType);
					this.update();
					return true;
				}
				else {
					return false;
				}
			}


			/**
			 * Instantiate a new Task with this TaskType
			 */
			Task newTask(String name, Process process) {
				log "Creating new Task " + parameters.name + " process=" + parameters.process;
				return parameters.process.new Task(parameters.name,this);
			}

			boolean isValidActorType(required ActorType actorType) {
				return true;
			}

			boolean isValidActor(required Actor actor) {
				return true;
			}

			boolean isValidUsedArtifactType(required ArtifactType artifactType) {
				return true;
			}

			boolean isValidProducedArtifactType(required ArtifactType artifactType) {
				return true;
			}

			public void setCreator(required Actor creator) {
				creator = parameters.creator;
			}

			boolean isAuthorizedActor(required Actor actor) {
				for (ActorType allowedActorType : allowedActorTypes) {
					if (parameters.actor.hasActorType(allowedActorType)) {
						return this.isValidActorType(allowedActorType);
					}
				}
				for (Actor allowedActor : allowedActors) {
					if (parameters.actor == allowedActor) {
						return this.isValidActor(allowedActor);
					}
				}
				return false;
			}
		}
		
		/** 
		 *  Represents a gateway in a process definition (ProcessType)
		 *  This concept is abstract
		 */
		public abstract concept Gateway extends Type {
			
			create(String name) {
				super(parameters.name);
			}
			
			delete() {
			}

			/**
			 * "Execute" the gateway in supplied Process
			 */
			abstract void execute(required Process process);
		}
		
		/**
		 * A sequence gateway, connecting two TaskTypes
		 */
		public concept Sequencing extends Gateway {
			
			TaskType inTaskType with ConceptInstance(virtualModelInstance=container.container);
			TaskType outTaskType with ConceptInstance(virtualModelInstance=container.container);
			
			create() {
				super("Sequence");
			}
			
			delete() {
			}
			
			/**
			 * "Execute" the sequence in supplied Process
			 */
			void execute(required Process process) {
				Task inTask = parameters.process.getTask(inTaskType);
				if (inTask.completed) {
					Task outTask = parameters.process.getTask(outTaskType);
					if (outTask.isStartable() && !outTask.completed) {
						outTask.startTask();
					}
				}
			}
		}
		
		/**
		 * A AndSplit gateway, connecting one input TaskType and multiple output TaskTypes with AND semantics
		 */
		public concept AndSplit extends Gateway {
			
			TaskType inTaskType with ConceptInstance(virtualModelInstance=container.container);
			TaskType[1,*] outTaskTypes with ConceptInstance(virtualModelInstance=container.container);
			
			create() {
				super("AndSplit");
			}
			
			delete() {
			}
			
			/**
			 * "Execute" the AndSplit in supplied Process
			 */
			void execute(required Process process) {
				Task inTask = parameters.process.getTask(inTaskType);
				if (inTask.completed) {
					for (TaskType taskType : outTaskTypes) {
						Task outTask = parameters.process.getTask(taskType);
						if (outTask.isStartable() && !outTask.completed) {
							outTask.startTask();
						}
					}
				}
			}
		}
		
		/**
		 * A OrSplit gateway, connecting one input TaskType and multiple output TaskTypes with OR semantics
		 */
		public concept OrSplit extends Gateway {
			
			TaskType inTaskType with ConceptInstance(virtualModelInstance=container.container);
			TaskType[1,*] outTaskTypes with ConceptInstance(virtualModelInstance=container.container);
			
			create() {
				super("OrSplit");
			}
			
			delete() {
			}
			
			/**
			 * "Execute" the OrSplit in supplied Process
			 */
			void execute(required Process process) {
				Task inTask = parameters.process.getTask(inTaskType);
				if (inTask.completed) {
					for (TaskType taskType : outTaskTypes) {
						Task outTask = parameters.process.getTask(taskType);
						if (outTask.isStartable() && !outTask.completed) {
							outTask.startTask();
						}
					}
				}
			}
		}
		
		/**
		 * A AndJoin gateway, connecting multiple input TaskType and one output TaskTypes with AND semantics
		 */
		public concept AndJoin extends Gateway {
			
			TaskType outTaskType with ConceptInstance(virtualModelInstance=container.container);
			TaskType[1,*] inTaskTypes with ConceptInstance(virtualModelInstance=container.container);
			
			create() {
				super("AndJoin");
			}
			
			delete() {
			}

			/**
			 * Indicates if all tasks are completed for supplied Process
			 */
			boolean areAllTasksCompleted(Process process) {
				for (TaskType taskType : inTaskTypes) {
					Task inTask = parameters.process.getTask(taskType);
					if (!inTask.completed) { 
						return false;
					}
				}
				return true;
			}

			/**
			 * "Execute" the AndJoin in supplied Process
			 */
			void execute(required Process process) {
				if (this.areAllTasksCompleted(parameters.process)) {
					Task outTask = parameters.process.getTask(outTaskType);
					if (outTask.isStartable() && !outTask.completed) {
						outTask.startTask();
					}
				}
			}
			
		}
		
		/**
		 * A OrJoin gateway, connecting multiple input TaskType and one output TaskTypes with AND semantics
		 */
		public concept OrJoin extends Gateway {
			
			TaskType outTaskType with ConceptInstance(virtualModelInstance=container.container);
			TaskType[1,*] inTaskTypes with ConceptInstance(virtualModelInstance=container.container);
			
			create() {
				super("OrJoin");
			}
			
			delete() {
			}
			
			/**
			 * Indicates if at least one task has been completed for supplied Process
			 */
			boolean isOneTaskCompleted(Process process) {
				for (TaskType taskType : inTaskTypes) {
					Task inTask = parameters.process.getTask(taskType);
					if (inTask.completed) {
						return false;
					}
				}
				return false;
			}

			/**
			 * "Execute" the OrJoin in supplied Process
			 */
			void execute(required Process process) {
				if (this.isOneTaskCompleted(parameters.process)) {
					Task outTask = parameters.process.getTask(outTaskType);
					if (outTask.isStartable() && !outTask.completed) {
						outTask.startTask();
					}
				}
			}
		}

		/**
		 * A BEGIN event in a process definition (ProcessType)
		 */
		public concept Begin extends TaskType {
			
			create() {
				super("Begin");
			}
			
			delete() {
				if ((container != null && container.initialTaskType) == this) {
					container.initialTaskType = null;
				}
			}

			BeginTask newTask(String name, Process process) {
				log "Creating new BeginTask " + parameters.name + " process=" + parameters.process;
				return parameters.process.new BeginTask(parameters.name,this);
			}
		}
		
		/**
		 * A END event in a process definition (ProcessType)
		 */
		public concept End extends TaskType {
			
			create() {
				super("End");
			}
			
			delete() {
				if (container != null) {
					container.finalTaskTypes.remove(this);
				}
			}

			EndTask newTask(String name, Process process) {
				log "Creating new BeginTask " + parameters.name + " process=" + parameters.process;
				return parameters.process.new EndTask(parameters.name,this);
			}
		}
	}

	/**
	 * A type of Actor, extending a collection of parent ActorType
	 */
	public concept ActorType extends Type {
		
		ActorType[0,*] parentActorTypes with ConceptInstance(virtualModelInstance=container);

		create(String name) {
			super(parameters.name);
		}
		delete() {
		}
		
		public void addParentActorType(required ActorType actorType) {
			parentActorTypes.add(parameters.actorType);
		}
		
		boolean isOrSpecializesActorType(required ActorType actorType) {
			if (parameters.actorType == this) {
				return true;
			}
			for (ActorType parentActorType : parentActorTypes) {
				if (parentActorType.isOrSpecializesActorType(parameters.actorType)) {
					return true;
				}
			}
			return false;
		}
	}

	/**
	 * Represents a concept which is defined as an instance of a single Type concept
	 */
	public abstract concept Instance extends ModelingElement {

		// The unique type of this Instance
		abstract Type type;

		create(String name) {
			super(parameters.name);
		}

		delete() {
		}
	}

	/**
	 * Represents a concept which is defined as an instance of multiple Type concepts
	 */
	public abstract concept MultiInstance extends ModelingElement {
		
		// The multiple types of this Instance
		abstract List<Type> types;

		create(String name) {
			super(parameters.name);
		}

		delete() {
		}
	}

	/**
	 * Represents an actor, as a MultiInstance of multiple ActorTypes
	 */
	public concept Actor extends MultiInstance {
		
		ActorType[0,*] types with ConceptInstance(virtualModelInstance=container);
		boolean isSenior;
		
		create(String name) {
			super(parameters.name);
			isSenior = false;
		}
		
		delete() {
		}
		
		public void addActorType(required ActorType actorType) {
			types.add(parameters.actorType);
		}
		
		boolean hasActorType(ActorType actorType) {
			for (ActorType type : types) {
				if (type.isOrSpecializesActorType(parameters.actorType)) {
					return true;
				}
			}
			return false;
		}
		
		void removeActorType(required ActorType actorType) {
			types.remove(parameters.actorType);
		}
	}

	/**
	 * Represents a process beeing executed, as a Instance of a ProcessType
	 */
	public concept Process extends Instance {
		
		ProcessType type with ConceptInstance(virtualModelInstance=container);
		Task[1,*] tasks with ConceptInstance(virtualModelInstance=container);
		Task initialTask with ConceptInstance(virtualModelInstance=container);
		
		boolean processCompleted;
		Date startProcessDate;
		Date completeProcessDate;

		Boolean isProcessStartable  {
			Boolean get() {
				for (Task task : tasks) {
					if (!task.isStartable()) {
						return false;
					}
				}
				return true;
			}
		};
		
		create(String name, ProcessType processType) {
			super(parameters.name);
			type = parameters.processType;
			for (TaskType taskType : type.taskTypes) {
				Task newTask = taskType.newTask(taskType.name,this);
				tasks.add(newTask);
			}
			initialTask = this.getTask(type.initialTaskType);
			processCompleted = false;
		}
		
		delete() {
		}
		
		public void startProcess() {
			log "Starting process " + name;
			log "initial task = " + initialTask;
			initialTask.startTask();
			startProcessDate = new Date();
		}
		
		Task getTask(required TaskType taskType) {
			return select unique Task from this where (selected.type == parameters.taskType);
		}
		
		void completeProcess() {
			log "Process " + name + " has finished";
			completeProcessDate = new Date();
			processCompleted = true;
		}
		
		public void executeGateways() {
			for (Gateway gateway : type.gateways) {
				gateway.execute(this);
			}
		}
		
		/**
		 * Represents a task beeing executed, as a Instance of a TaskType
		 */
		public concept Task extends Instance {
			
			TaskType type with ConceptInstance(virtualModelInstance=container.container);
			Date beginDate;
			Date endDate;
			Actor[0,*] performingActors with ConceptInstance(virtualModelInstance=container.container);
			Artifact[0,*] usedArtifacts with ConceptInstance(virtualModelInstance=container.container);
			Artifact[0,*] producedArtifacts with ConceptInstance(virtualModelInstance=container.container);
			boolean isActive;
			boolean completed;
			
			String performingActorsLabel  {
				String get() {
					if (performingActors.size > 0) {
						String label = "";
						for (Actor actor : performingActors) {
							label = label + " " + actor.name;
						}
						return label;
					}
					else {
						return "No actor assigned";
					}
				}
				set(String value) {
				}
			};
			
			String statusLabel  {
				String get() {
					if (this.isStartable()) {
						if (isActive || completed) {
							if (completed) {
								return "Completed";
							}
							else {
								return beginDate.toString.substring(0,beginDate.toString.length - 9);
							}
						}
						else {
							return "Not started";
						}
					}
					else {
						return "Not startable";
					}
				}
				set(String value) {
				}
			};
			
			create(String name, TaskType taskType) {
				super(parameters.name);
				type = parameters.taskType;
				isActive = false;
				completed = false;
			}
			
			delete() {
			}
			
			boolean isAuthorizedActor(required Actor actor) {
				return type.isAuthorizedActor(parameters.actor);
			}
			
			public void addToPerformingActors(required Actor actor) {
				if (this.isAuthorizedActor(parameters.actor)) {
					log "This actor is AUTHORIZED";
					performingActors.add(parameters.actor);
					notify "performingActorsLabel";
					notify "statusLabel";
					notify "isStartable()";
				}
				else {
					log "This actor is NOT AUTHORIZED";
				}
			}
			
			boolean isAuthorizedProducedArtifact(required Artifact artifact) {
				for (ArtifactType allowedArtifactType : type.producedArtifactTypes) {
					if (parameters.artifact.hasArtifactType(allowedArtifactType)) {
						return true;
					}
				}
				return false;
			}
			
			public void addToProducedArtifacts(required Artifact artifact) {
				if (this.isAuthorizedProducedArtifact(parameters.artifact)) {
					log "This produced artifact is AUTHORIZED";
					producedArtifacts.add(parameters.artifact);
				}
				else {
					log "This produced artifact is NOT AUTHORIZED";
				}
			}
			
			boolean isAuthorizedUsedArtifact(required Artifact artifact) {
				for (ArtifactType allowedArtifactType : type.usedArtifactTypes) {
					if (parameters.artifact.hasArtifactType(allowedArtifactType)) {
						return true;
					}
				}
				return false;
			}
			
			public void addToUsedArtifacts(required Artifact artifact) {
				if (this.isAuthorizedUsedArtifact(parameters.artifact)) {
					log "This used artifact is AUTHORIZED";
					usedArtifacts.add(parameters.artifact);
				}
				else {
					log "This used artifact is NOT AUTHORIZED";
				}
			}
			
			public void startTask() {
				beginDate = new Date();
				isActive = true;
				notify "statusLabel";
				log "Start abstract task " + this;
			}
			
			public void finishTask() {
				isActive = false;
				completed = true;
				endDate = new Date();
				container.executeGateways();
				notify "statusLabel";
				log "Finish abstract task " + this;
			}
			
			boolean isStartable() {
				return performingActors.size > 0;
			}
			
		}
		
		/**
		 * Represents a BEGIN task beeing executed, as a Instance of a Begin
		 */
		public concept BeginTask extends Task {
			
			create(String name, Begin taskType) {
				super(parameters.name,parameters.taskType);
			}

			delete() {
			}

			boolean isStartable() {
				return true;
			}

			public void startTask() {
				super.startTask();
				log "Start BEGIN " + this;
				this.finishTask();
			}
		}
		
		/**
		 * Represents a END task beeing executed, as a Instance of a End
		 */
		public concept EndTask extends Task {

			create(String name, End taskType) {
				super(parameters.name,parameters.taskType);
			}

			delete() {
			}

			public void startTask() {
				super.startTask();
				log "Start EndTask";
				this.finishTask();
			}
			
			boolean isStartable() {
				return true;
			}
			
			public void finishTask() {
				super.finishTask();
				log "Finish EndTask";
				container.completeProcess();
			}
		}
	}

	/**
	 * Represents a type of artifact
	 */
	public concept ArtifactType extends Type {

		create(String name) {
			super(parameters.name);
		}

		delete() {
		}

		/**
		 * Instantiates a new artifact with this type
		 */
		Artifact newArtifact(String name) {
			Artifact returned = new Artifact(parameters.name);
			returned.types.add(this);
			return returned;
		}
	}

	/**
	 * Represents an artifact, as a MultiInstance of multiple ArtifactType
	 */
	public concept Artifact extends MultiInstance {
		
		ArtifactType[0,*] types with ConceptInstance(virtualModelInstance=container);

		create(String name) {
			super(name);
		}
		
		delete() {
		}
		
		boolean hasArtifactType(ArtifactType artifactType) {
			for (ArtifactType type : types) {
				if (type == parameters.artifactType) {
					return true;
				}
			}
			return false;
		}
	}

	/**
	 * A property which references all Actor declared in this model
	 */
	List<Actor> actorList  {
		List<Actor> get() {
			return select Actor from this;
		}
	};

	/**
	 * Return actor identified by supplied name
	 */
	Actor getActor(required String name) {
		return select unique Actor from this where (selected.name == parameters.name);
	}


}
