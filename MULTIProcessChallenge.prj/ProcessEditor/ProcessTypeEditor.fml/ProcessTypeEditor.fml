namespace "http://www.openflexo.org/MULTIProcessChallenge" as MULTIPROCESSCHALLENGE;

use org.openflexo.technologyadapter.diagram.TypedDiagramModelSlot as DIAGRAM;
use org.openflexo.foundation.fml.rt.FMLRTVirtualModelInstanceModelSlot as FMLRT;
use org.openflexo.foundation.fml.ta.FMLModelSlot as FML;

import org.openflexo.technologyadapter.diagram.model.DiagramShape;
import org.openflexo.technologyadapter.diagram.model.Diagram;
import org.openflexo.technologyadapter.diagram.model.DiagramConnector;

import [MULTIPROCESSCHALLENGE + "/MetaModel.fml"] as MetaModel;
import [MULTIPROCESSCHALLENGE + "/ProcessEditor.fml"] as ProcessEditor;

import [MULTIPROCESSCHALLENGE + "/ProcessType"] as PROCESS_TYPE_DIAGRAM_SPECIFICATION;
import [MULTIPROCESSCHALLENGE + "/ProcessType/ExampleDiagram.diagram"] as EXAMPLE_DIAGRAM;
import [EXAMPLE_DIAGRAM:"SYL-2"] as DIAGRAM_SHAPE;
import [EXAMPLE_DIAGRAM:"SYL-29"] as DIAGRAM_SHAPE2;
import [EXAMPLE_DIAGRAM:"SYL-30"] as DIAGRAM_SHAPE3;
import [EXAMPLE_DIAGRAM:"SYL-3"] as DIAGRAM_SHAPE4;
import [EXAMPLE_DIAGRAM:"SYL-6"] as DIAGRAM_SHAPE5;
import [EXAMPLE_DIAGRAM:"SYL-7"] as DIAGRAM_SHAPE6;
import [EXAMPLE_DIAGRAM:"SYL-13"] as DIAGRAM_SHAPE7;
import [EXAMPLE_DIAGRAM:"SYL-4"] as DIAGRAM_SHAPE8;
import [EXAMPLE_DIAGRAM:"SYL-19"] as DIAGRAM_SHAPE9;
import [EXAMPLE_DIAGRAM:"SYL-22"] as DIAGRAM_SHAPE10;
import [EXAMPLE_DIAGRAM:"SYL-23"] as DIAGRAM_SHAPE11;
import [EXAMPLE_DIAGRAM:"SYL-5"] as DIAGRAM_CONNECTOR;
import [EXAMPLE_DIAGRAM:"SYL-8"] as DIAGRAM_CONNECTOR2;
import [EXAMPLE_DIAGRAM:"SYL-21"] as DIAGRAM_CONNECTOR3;
import [EXAMPLE_DIAGRAM:"SYL-20"] as DIAGRAM_CONNECTOR4;
import [EXAMPLE_DIAGRAM:"SYL-24"] as DIAGRAM_CONNECTOR5;
import [EXAMPLE_DIAGRAM:"SYL-26"] as DIAGRAM_CONNECTOR6;
import [EXAMPLE_DIAGRAM:"SYL-27"] as DIAGRAM_CONNECTOR7;
import [EXAMPLE_DIAGRAM:"SYL-28"] as DIAGRAM_CONNECTOR8;

/**
 *  A model which aims at providing a graphical editor for a process model (an instance of MetaModel)
 *  To do so, we federate a model and a diagram
 */
@URI("http://www.openflexo.org/MULTIProcessChallenge/ProcessTypeEditor.fml")
@Version("0.1")
model ProcessTypeEditor {

	// The model beeing edited
	MetaModel processModel with ModelInstance(isRequired=true);
	// The diagram representing the model
	Diagram diagram with TypedDiagram(
		diagramSpecification=PROCESS_TYPE_DIAGRAM_SPECIFICATION,
		isRequired=true,
		paletteElementBindings={
			PaletteElementBinding:(call=new BeginGR::dropBeginNodeAtTopLevel(), paletteElementId="http://www.openflexo.org/MULTIProcessChallenge/ProcessType/Palette.palette#BeginNode"), 
			PaletteElementBinding:(call=new TaskTypeGR::dropTaskTypeGRAtTopLevel(null,null), paletteElementId="http://www.openflexo.org/MULTIProcessChallenge/ProcessType/Palette.palette#TaskTypeGR"), 
			PaletteElementBinding:(call=new EndGR::dropEndGRAtTopLevel(), paletteElementId="http://www.openflexo.org/MULTIProcessChallenge/ProcessType/Palette.palette#EndGR"), 
			PaletteElementBinding:(call=new AndSplitGR::dropAndSplitGRAtTopLevel(), paletteElementId="http://www.openflexo.org/MULTIProcessChallenge/ProcessType/Palette.palette#AndSplitGR"), 
			PaletteElementBinding:(call=new AndJoinGR::dropAndJoinGRAtTopLevel(), paletteElementId="http://www.openflexo.org/MULTIProcessChallenge/ProcessType/Palette.palette#AndJoinGR"), 
			PaletteElementBinding:(call=new ArtifactTypeGR::dropArtifactTypeGRAtTopLevel(null,null), paletteElementId="http://www.openflexo.org/MULTIProcessChallenge/ProcessType/Palette.palette#ArtifactTypeGR"), 
			PaletteElementBinding:(call=new ActorTypeGR::dropActorTypeGRAtTopLevel(null,null), paletteElementId="http://www.openflexo.org/MULTIProcessChallenge/ProcessType/Palette.palette#ActorTypeGR"), 
			PaletteElementBinding:(call=new ActorGR::dropActorGRAtTopLevel(null), paletteElementId="http://www.openflexo.org/MULTIProcessChallenge/ProcessType/Palette.palette#ActorGR"),
			PaletteElementBinding:(call=new ProcessTypeGR::dropProcessTypeGRAtTopLevel(null), paletteElementId="http://www.openflexo.org/MULTIProcessChallenge/ProcessType/Palette.palette#ProcessTypeGR")});

	/**
	 * Constructor for a ProcessTypeEditor given a process model, the diagram will be created
	 */
	create::init(required MetaModel processModel, required String diagramName) {
		diagram = DIAGRAM::CreateDiagram(resourceName=parameters.diagramName,resourceCenter=this.resourceCenter,relativePath="/Diagrams");
		processModel = parameters.processModel;
	}

	/**
	 * Utility method: return representation of supplied processType
	 */
	ProcessTypeGR getProcessTypeGR(required ProcessType processType) {
		return select unique ProcessTypeGR from this;
	}

	/**
	 * Utility method: return representation of supplied taskType
	 */
	ShapeBasedGR getTaskTypeGR(required TaskType taskType) {
		if (parameters.taskType instanceof Begin) {
			return this.getBeginGR((Begin)parameters.taskType);
		}
		if (parameters.taskType instanceof End) {
			return this.getEndGR((End)parameters.taskType);
		}
		return select unique TaskTypeGR from this where (selected.taskType == parameters.taskType);
	}

	/**
	 * Utility method: return representation of supplied beginEvent
	 */
	BeginGR getBeginGR(required Begin beginEvent) {
		return select unique BeginGR from this where (selected.beginEvent == parameters.beginEvent);
	}

	/**
	 * Utility method: return representation of supplied endEvent
	 */
	EndGR getEndGR(required End endEvent) {
		return select unique EndGR from this where (selected.endEvent == parameters.endEvent);
	}

	/**
	 * Utility method: return representation of supplied gateway
	 */
	ShapeBasedGR getGatewayGR(required Gateway gateway) {
		if (parameters.gateway.conceptType.name == "AndSplit") {
			return select unique AndSplitGR from this where (selected.andSplit == parameters.gateway);
		}
		else {
			if (parameters.gateway.conceptType.name == "AndJoin") {
				return select unique AndJoinGR from this where (selected.andJoin == parameters.gateway);
			}
		}
		return null;
	}

	/**
	 * Utility method: return representation of supplied actor
	 */
	ActorGR getActorGR(required Actor actor) {
		return select unique ActorGR from this where (selected.actor == parameters.actor);
	}

	/**
	 * Abstract concept defining a shape-based representation
	 */
	public abstract concept ShapeBasedGR {
		abstract DiagramShape shape;
	}

	/**
	 * Abstract concept defining a connector-based representation
	 */
	public abstract concept ConnectorBasedGR {
		abstract DiagramConnector connector;
	}

	/**
	 * Representation of a ProcessType: federation of an instance of ProcessType and two shapes
	 */
	concept ProcessTypeGR extends ShapeBasedGR {
		
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE2,exampleLabel="");
		DiagramShape header with ShapeRole(metamodelElement=DIAGRAM_SHAPE3,exampleLabel="Process",label=processType.name,containerElement=shape);
		ProcessType processType with ConceptInstance(virtualModelInstance=processModel);

		ProcessTypeGR dropProcessTypeGRAtTopLevel(required String name) with DropScheme(targetType=ProcessTypeEditor) {
			shape = DIAGRAM::AddShape(container=topLevel) in diagram;
			header = DIAGRAM::AddShape() in diagram;
			processType = new ProcessType(parameters.name);
		}
		
		delete() {
			delete shape;
			delete header;
		}

		public ProcessEditor newProcess(required String processName) {
			log"Creating new process " + parameters.processName;
			log "processModel=" + processModel;
			log "processType=" + processType;
			log "container=" + container;
			ProcessEditor newProcessEditor = 
				new ProcessEditor::init(processModel,processType,parameters.processName,container) with (name=parameters.processName,rc=this.resourceCenter);
			return newProcessEditor;
		}
	}

	/**
	 * Representation of a TaskType
	 */
	concept TaskTypeGR extends ShapeBasedGR {

		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE4,exampleLabel="TaskType",label=taskType.name);
		TaskType taskType with ConceptInstance(virtualModelInstance=processModel);

		TaskTypeGR dropTaskTypeGRAtTopLevel(required String name, required Concept<? extends TaskType> taskTypeConcept) with DropScheme(targetType=ProcessTypeGR) {
			// log"dropTaskTypeGRAtTopLevel taskTypeConcept=" + parameters.taskTypeConcept;
			shape = DIAGRAM::AddShape(container=target.shape) in diagram;
			List<?> arguments = new ArrayList();
			arguments.add(parameters.name);
			taskType = FMLRT::NewInstance(conceptType=parameters.taskTypeConcept,container=target.processType,args=arguments);
			// taskType = target.processType.new TaskType(parameters.name);
			taskType.name = parameters.name;
			target.processType.addToTaskTypes(taskType);
		}
		
		public delete() {
			delete shape;
			delete taskType;
		}
	}


	/**
	 * Representation of a BeginEvent
	 */
	concept BeginGR extends ShapeBasedGR {
		
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE,exampleLabel="Begin");
		Begin beginEvent with ConceptInstance(virtualModelInstance=processModel);
		
		BeginGR dropBeginNodeAtTopLevel() with DropScheme(targetType=ProcessTypeGR) {
			shape = DIAGRAM::AddShape(container=target.shape) in diagram;
			beginEvent = target.processType.new Begin();
			target.processType.taskTypes.add(beginEvent);
			target.processType.setInitialTaskType(beginEvent);
		}
		
		public delete() {
			delete shape;
			delete beginEvent;
		}
	}

	/**
	 * Representation of a Sequencing starting from a Begin event
	 */
	concept StartSequencingGR extends ConnectorBasedGR {
		
		DiagramConnector connector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR,exampleLabel="");
		Sequencing sequencing with ConceptInstance(virtualModelInstance=processModel);
		
		StartSequencingGR linkBeginGRToTaskTypeGR() with LinkScheme(fromType=BeginGR,toType=TaskTypeGR) {
			connector = DIAGRAM::AddConnector(fromShape=fromTarget.shape,toShape=toTarget.shape) in diagram;
			sequencing = new Sequencing();
			fromTarget.beginEvent.container.addToGateways(sequencing);
			sequencing.inTaskType = fromTarget.beginEvent;
			sequencing.outTaskType = toTarget.taskType;
		}
		
		public delete() {
			delete connector;
			delete sequencing;
		}
	}

	/**
	 * Representation of a EndEvent
	 */
	concept EndGR extends ShapeBasedGR {
		
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE5,exampleLabel="Shape");
		DiagramShape insideShape with ShapeRole(metamodelElement=DIAGRAM_SHAPE6,exampleLabel="Shape");
		End endEvent with ConceptInstance(virtualModelInstance=processModel);
		
		EndGR dropEndGRAtTopLevel() with DropScheme(targetType=ProcessTypeGR) {
			shape = DIAGRAM::AddShape(container=target.shape) in diagram;
			insideShape = DIAGRAM::AddShape(container=target.shape) in diagram;
			endEvent = target.processType.new End();
			target.processType.addToTaskTypes(endEvent);
			target.processType.addToFinalTaskTypes(endEvent);
		}
		
		public delete() {
			delete shape;
			delete insideShape;
			delete endEvent;
		}
	}

	/**
	 * Representation of a Sequencing
	 */
	concept SequencingGR extends ConnectorBasedGR {
		
		DiagramConnector connector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR,exampleLabel="");
		Sequencing sequencing with ConceptInstance(virtualModelInstance=processModel);
		
		SequencingGR linkTaskTypeGRToTaskTypeGR() with LinkScheme(fromType=TaskTypeGR,toType=TaskTypeGR) {
			connector = DIAGRAM::AddConnector(fromShape=fromTarget.shape,toShape=toTarget.shape) in diagram;
			sequencing = fromTarget.taskType.container.new Sequencing();
			fromTarget.taskType.container.addToGateways(sequencing);
			sequencing.inTaskType = fromTarget.taskType;
			sequencing.outTaskType = toTarget.taskType;
		}
	}

	/**
	 * Representation of a Sequencing ending on a End event
	 */
	concept EndSequencingGR extends ConnectorBasedGR {
		
		DiagramConnector connector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR,exampleLabel="");
		Sequencing sequencing with ConceptInstance(virtualModelInstance=processModel);
		
		EndSequencingGR linkTaskTypeGRtoEndGR() with LinkScheme(fromType=TaskTypeGR,toType=EndGR) {
			connector = DIAGRAM::AddConnector(fromShape=fromTarget.shape,toShape=toTarget.shape) in diagram;
			sequencing = fromTarget.taskType.container.new Sequencing();
			fromTarget.taskType.container.addToGateways(sequencing);
			sequencing.inTaskType = fromTarget.taskType;
			sequencing.outTaskType = toTarget.endEvent;
		}
	}

	/**
	 * Representation of a AndSplit
	 */
	concept AndSplitGR extends ShapeBasedGR {
		
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE8,exampleLabel="");
		AndSplit andSplit with ConceptInstance(virtualModelInstance=processModel);
		
		AndSplitGR dropAndSplitGRAtTopLevel() with DropScheme(targetType=ProcessTypeGR) {
			shape = DIAGRAM::AddShape(container=target.shape) in diagram;
			andSplit = target.processType.new AndSplit();
			target.processType.addToGateways(andSplit);
		}
		
		delete() {
			delete shape;
		}
	}

	/**
	 * Representation of a connexion between a TaskType and a AndSplit
	 */
	concept InAndSplitGR extends ConnectorBasedGR {
		
		DiagramConnector connector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR2,exampleLabel="");
		TaskType taskType with ConceptInstance(virtualModelInstance=container.processModel);
		AndSplit andSplit with ConceptInstance(virtualModelInstance=container.processModel);
		
		InAndSplitGR linkTaskTypeGRToAndSplitGR() with LinkScheme(fromType=TaskTypeGR,toType=AndSplitGR) {
			connector = DIAGRAM::AddConnector(fromShape=fromTarget.shape,toShape=toTarget.shape) in diagram;
			taskType = fromTarget.taskType;
			andSplit = toTarget.andSplit;
			andSplit.inTaskType = taskType;
		}
		
		public delete() {
			delete connector;
			andSplit.inTaskType = null;
		}
	}

	/**
	 * Representation of a connexion between a AndSplit and a TaskType
	 */
	concept OutAndSplitGR extends ConnectorBasedGR {
		
		DiagramConnector connector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR2,exampleLabel="");
		AndSplit andSplit with ConceptInstance(virtualModelInstance=container.processModel);
		TaskType taskType with ConceptInstance(virtualModelInstance=container.processModel);
		
		OutAndSplitGR linkAndSplitGRToTaskTypeGR() with LinkScheme(fromType=AndSplitGR,toType=TaskTypeGR) {
			connector = DIAGRAM::AddConnector(fromShape=fromTarget.shape,toShape=toTarget.shape) in diagram;
			andSplit = fromTarget.andSplit;
			taskType = toTarget.taskType;
			andSplit.outTaskTypes.add(taskType);
		}
		
		public delete() {
			delete connector;
			andSplit.outTaskTypes.remove(taskType);
		}
	}

	/**
	 * Representation of a AndJoin
	 */
	concept AndJoinGR extends ShapeBasedGR {
		
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE7,exampleLabel="");
		AndJoin andJoin with ConceptInstance(virtualModelInstance=processModel);
		
		AndJoinGR dropAndJoinGRAtTopLevel() with DropScheme(targetType=ProcessTypeGR) {
			shape = DIAGRAM::AddShape(container=target.shape) in diagram;
			andJoin = target.processType.new AndJoin();
			target.processType.addToGateways(andJoin);
		}
	}

	/**
	 * Representation of a connexion between a AndJoin and a TaskType
	 */
	concept OutAndJoinGR extends ConnectorBasedGR {
		
		DiagramConnector connector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR2,exampleLabel="");
		AndJoin andJoin with ConceptInstance(virtualModelInstance=container.processModel);
		TaskType taskType with ConceptInstance(virtualModelInstance=container.processModel);
		
		OutAndJoinGR linkAndJoinGRToTaskTypeGR() with LinkScheme(fromType=AndJoinGR,toType=TaskTypeGR) {
			connector = DIAGRAM::AddConnector(fromShape=fromTarget.shape,toShape=toTarget.shape) in diagram;
			andJoin = fromTarget.andJoin;
			taskType = toTarget.taskType;
			andJoin.outTaskType = taskType;
		}
		
		public delete() {
			delete connector;
			andJoin.outTaskType = null;
		}
	}

	/**
	 * Representation of a connexion between a TaskType and a AndJoin
	 */
	concept InAndJoinGR extends ConnectorBasedGR {
		
		DiagramConnector connector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR2,exampleLabel="");
		TaskType taskType with ConceptInstance(virtualModelInstance=container.processModel);
		AndJoin andJoin with ConceptInstance(virtualModelInstance=container.processModel);
		
		InAndJoinGR linkTaskTypeGRToAndJoinGR() with LinkScheme(fromType=TaskTypeGR,toType=AndJoinGR) {
			connector = DIAGRAM::AddConnector(fromShape=fromTarget.shape,toShape=toTarget.shape) in diagram;
			taskType = fromTarget.taskType;
			andJoin = toTarget.andJoin;
			andJoin.inTaskTypes.add(taskType);
		}
		
		public delete() {
			delete connector;
			andJoin.inTaskTypes.remove(taskType);
		}
	}

	/**
	 * Representation of a ArtifactType
	 */
	concept ArtifactTypeGR extends ShapeBasedGR {
		
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE9,exampleLabel="ArtefactType",label=artifactType.name);
		ArtifactType artifactType with ConceptInstance(virtualModelInstance=processModel);
		
		ArtifactTypeGR dropArtifactTypeGRAtTopLevel(required String name, required Concept<? extends ArtifactType> artefactTypeConcept) with DropScheme(targetType=ProcessTypeEditor) {
			shape = DIAGRAM::AddShape(container=topLevel) in diagram;
			List<?> arguments = new ArrayList();
			arguments.add(parameters.name);
			artifactType = FMLRT::NewInstance(conceptType=parameters.artefactTypeConcept,container=processModel,args=arguments);
		}
		
		public delete() {
			delete shape;
			delete artifactType;
		}
	}

	/**
	 * Representation of a ArtifactType used by a TaskType
	 */
	concept UsedArtefactType extends ConnectorBasedGR {
		
		DiagramConnector connector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR3,exampleLabel="uses",label="uses");
		TaskType taskType with ConceptInstance(virtualModelInstance=container.processModel);
		ArtifactType artefactType with ConceptInstance(virtualModelInstance=container.processModel);
		
		UsedArtefactType linkArtifactTypeGRToTaskTypeGR() with LinkScheme(fromType=ArtifactTypeGR,toType=TaskTypeGR) {
			connector = DIAGRAM::AddConnector(fromShape=fromTarget.shape,toShape=toTarget.shape) in diagram;
			taskType = toTarget.taskType;
			artefactType = fromTarget.artifactType;
			taskType.usedArtifactTypes.add(artefactType);
		}
		
		public delete() {
			delete connector;
			taskType.usedArtifactTypes.remove(artefactType);
		}
	}

	/**
	 * Representation of a ArtifactType produced by a TaskType
	 */
	concept ProducedArtefactType extends ConnectorBasedGR {
		
		DiagramConnector connector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR4,exampleLabel="produces",label="produces");
		TaskType taskType with ConceptInstance(virtualModelInstance=container.processModel);
		ArtifactType artefactType with ConceptInstance(virtualModelInstance=container.processModel);
		
		ProducedArtefactType linkTaskTypeGRToArtifactTypeGR() with LinkScheme(fromType=TaskTypeGR,toType=ArtifactTypeGR) {
			connector = DIAGRAM::AddConnector(fromShape=fromTarget.shape,toShape=toTarget.shape) in diagram;
			taskType = fromTarget.taskType;
			artefactType = toTarget.artifactType;
			taskType.producedArtifactTypes.add(artefactType);
		}
		
		public delete() {
			delete connector;
			taskType.producedArtifactTypes.remove(artefactType);
		}
	}

	/**
	 * Representation of a ActorType
	 */
	concept ActorTypeGR extends ShapeBasedGR {
		
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE10,exampleLabel="ActorType",label=actorType.name);
		ActorType actorType with ConceptInstance(virtualModelInstance=processModel);

		ActorTypeGR dropActorTypeGRAtTopLevel(required String name, required Concept<? extends ActorType> actorTypeConcept) with DropScheme(targetType=ProcessTypeEditor) {
			shape = DIAGRAM::AddShape(container=topLevel) in diagram;
			List<?> arguments = new ArrayList();
			arguments.add(parameters.name);
			actorType = FMLRT::NewInstance(conceptType=parameters.actorTypeConcept,container=processModel,args=arguments);
		}
		
		public delete() {
			delete shape;
			delete actorType;
		}
	}

	/**
	 * Representation of an Actor
	 */
	concept ActorGR extends ShapeBasedGR {
		
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE11,exampleLabel="Actor",label=actor.name);
		Actor actor with ConceptInstance(virtualModelInstance=processModel);

		ActorGR dropActorGRAtTopLevel(required String name) with DropScheme(targetType=ProcessTypeEditor) {
			shape = DIAGRAM::AddShape(container=topLevel) in diagram;
			actor = new Actor(parameters.name);
		}
	}

	/**
	 * Represents an Actor having an ActorType
	 */
	concept HasActorTypeGR extends ConnectorBasedGR {
		
		DiagramConnector connector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR5,exampleLabel="",label="");
		Actor actor with ConceptInstance(virtualModelInstance=container.processModel);
		ActorType actorType with ConceptInstance(virtualModelInstance=container.processModel);
		
		HasActorTypeGR linkActorGRToActorTypeGR() with LinkScheme(fromType=ActorGR,toType=ActorTypeGR) {
			connector = DIAGRAM::AddConnector(fromShape=fromTarget.shape,toShape=toTarget.shape) in diagram;
			actor = fromTarget.actor;
			actorType = toTarget.actorType;
			actor.addActorType(actorType);
		}
		
		public delete() {
			delete connector;
			actor.removeActorType(actorType);
		}
	}

	/**
	 * Represents an ActorType specialization
	 */
	concept ParentActorTypeGR extends ConnectorBasedGR {
		
		DiagramConnector connector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR6,exampleLabel="");
		
		ParentActorTypeGR linkActorTypeGRToActorTypeGR() with LinkScheme(fromType=ActorTypeGR,toType=ActorTypeGR) {
			connector = DIAGRAM::AddConnector(fromShape=fromTarget.shape,toShape=toTarget.shape) in diagram;
			fromTarget.actorType.addParentActorType(toTarget.actorType);
		}
	}

	/**
	 * Represents a TaskType allowed for a given ActorType
	 */
	concept AllowedActorTypeGR extends ConnectorBasedGR {
		
		DiagramConnector connector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR7,exampleLabel="");
		TaskType taskType with ConceptInstance(virtualModelInstance=container.processModel);
		ActorType actorType with ConceptInstance(virtualModelInstance=container.processModel);
		
		AllowedActorTypeGR linkActorTypeGRToTaskTypeGR() with LinkScheme(fromType=ActorTypeGR,toType=TaskTypeGR) {
			taskType = toTarget.taskType;
			actorType = fromTarget.actorType;
			if (taskType.addAllowedActorType(actorType)) {
				connector = DIAGRAM::AddConnector(fromShape=fromTarget.shape,toShape=toTarget.shape) in diagram;
			}
			else {
				log "Invalid ActorType";
			}
		}
		public delete() {
			delete connector;
			taskType.allowedActorTypes.remove(actorType);
		}
	}

	/**
	 * Represents a TaskType allowed for a given Actor
	 */
	concept AllowedActorGR extends ConnectorBasedGR {
		
		DiagramConnector connector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR8,exampleLabel="");
		
		AllowedActorGR linkActorGRToTaskTypeGR() with LinkScheme(fromType=ActorGR,toType=TaskTypeGR) {
			connector = DIAGRAM::AddConnector(fromShape=fromTarget.shape,toShape=toTarget.shape) in diagram;
			toTarget.taskType.addAllowedActor(fromTarget.actor);
		}
	}

}
