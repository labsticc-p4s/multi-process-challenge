namespace "http://www.openflexo.org/MULTIProcessChallenge" as MULTIPROCESSCHALLENGE;

use org.openflexo.technologyadapter.diagram.TypedDiagramModelSlot as DIAGRAM;
use org.openflexo.foundation.fml.rt.FMLRTVirtualModelInstanceModelSlot as FMLRT;

import org.openflexo.technologyadapter.diagram.model.DiagramShape;
import org.openflexo.technologyadapter.diagram.model.Diagram;
import org.openflexo.technologyadapter.diagram.model.DiagramConnector;

import [MULTIPROCESSCHALLENGE + "/MetaModel.fml"] as MetaModel;
import [MULTIPROCESSCHALLENGE + "/ProcessTypeEditor.fml"] as ProcessTypeEditor;

import [MULTIPROCESSCHALLENGE + "/Process"] as DIAGRAM_SPECIFICATION;
import [MULTIPROCESSCHALLENGE + "/Process/ExampleDiagram.diagram"] as EXAMPLE_DIAGRAM;
import [EXAMPLE_DIAGRAM:"SYL-29"] as DIAGRAM_SHAPE;
import [EXAMPLE_DIAGRAM:"SYL-23"] as DIAGRAM_SHAPE2;
import [EXAMPLE_DIAGRAM:"SYL-30"] as DIAGRAM_SHAPE3;
import [EXAMPLE_DIAGRAM:"SYL-2"] as DIAGRAM_SHAPE4;
import [EXAMPLE_DIAGRAM:"SYL-3"] as DIAGRAM_SHAPE5;
import [EXAMPLE_DIAGRAM:"SYL-32"] as DIAGRAM_SHAPE6;
import [EXAMPLE_DIAGRAM:"SYL-33"] as DIAGRAM_SHAPE7;
import [EXAMPLE_DIAGRAM:"SYL-34"] as DIAGRAM_SHAPE8;
import [EXAMPLE_DIAGRAM:"SYL-6"] as DIAGRAM_SHAPE9;
import [EXAMPLE_DIAGRAM:"SYL-4"] as DIAGRAM_SHAPE10;
import [EXAMPLE_DIAGRAM:"SYL-5"] as DIAGRAM_CONNECTOR;
import [EXAMPLE_DIAGRAM:"SYL-28"] as DIAGRAM_CONNECTOR2;
import [EXAMPLE_DIAGRAM:"SYL-29"] as DIAGRAM_SHAPE11;
import [EXAMPLE_DIAGRAM:"SYL-23"] as DIAGRAM_SHAPE12;
import [EXAMPLE_DIAGRAM:"SYL-30"] as DIAGRAM_SHAPE13;
import [EXAMPLE_DIAGRAM:"SYL-32"] as DIAGRAM_SHAPE14;
import [EXAMPLE_DIAGRAM:"SYL-33"] as DIAGRAM_SHAPE15;
import [EXAMPLE_DIAGRAM:"SYL-34"] as DIAGRAM_SHAPE16;
@URI("http://www.openflexo.org/MULTIProcessChallenge/MULTIProcessChallenge.prj/ProcessEditor/ProcessEditor.fml")
@Version("0.1")
model ProcessEditor {
	
	MetaModel processModel with ModelInstance(isRequired=true);
	Process process with ConceptInstance(virtualModelInstance=processModel);
	ProcessTypeEditor processTypeEditor with ModelInstance(isRequired=true);
	
	Diagram diagram with TypedDiagram(
		diagramSpecification=null,
		isRequired=true,
		paletteElementBindings={
			PaletteElementBinding:(call=new ActorGR::dropActorGRAtTopLevel(null), paletteElementId="http://www.openflexo.org/MULTIProcessChallenge/ProcessEditor/Process/Palette.palette#ActorGR")});

	@UI(
		@TextField(value="processName")
	)
	create::init(required MetaModel _model, required ProcessType processType, required String processName, required ProcessTypeEditor processTypeEditor) {
		diagram = DIAGRAM::CreateDiagram(resourceName=parameters.processType.name + "_" + parameters.processName,resourceCenter=this.resourceCenter,relativePath="/Diagrams");
		processModel = parameters.processModel;
		processTypeEditor = parameters.processTypeEditor;
		ProcessGR newProcessGR = new ProcessGR::instantiateProcess(parameters.processType,parameters.processName);
		process = newProcessGR.process;
		log "Les tasks= " + newProcessGR.process.tasks;
		for (Object task : process.tasks) {
			log "Task=" + task;
			if (task.type.concept.name == "Begin") {
				new BeginGR::representTask(task);
				log "New begin";
			}
			else {
				if (task.type.concept.name == "End") {
					new EndGR::representTask(task);
					log "New end";
				}
				else {
					new TaskGR::representTask(task);
					log "New task";
				}
			}
		}
		for (Object gateway : process.type.gateways) {
			if ((gateway.concept.name = "AndSplit") || (gateway.concept.name = "AndJoin")) {
				new GatewayGR::representGateway(gateway,process);
			}
		}
		for (Object sequencing : process.type.sequencingList) {
			log "On cherche a representer la sequence " + sequencing;
			new SequencingGR::representSequencing(sequencing,process);
		}
		for (Object andSplit : process.type.andSplitList) {
			new AndSplitConnectorsGR::representAndSplit(andSplit,process);
		}
		for (Object actor : model.actorList) {
			new ActorGR(actor);
		}
		for (Object andJoin : process.type.andJoinList) {
			new AndJoinConnectorsGR::representAndSplit(andJoin,process);
		}
		for (Object task : process.tasks) {
			for (Object actor : task.performingActors) {
				new ActorAssignationGR::representAssignation(actor,task);
			}
		}
	}

	delete() {
	}

	ProcessGR getProcessGR(required Process process) {
		return select unique ProcessGR from this;
	}

	BeginGR getTaskGR(required Task task) {
		if (parameters.task.type.concept.name == "Begin") {
			return this.getBeginGR(parameters.task);
		}
		if (parameters.task.type.concept.name == "End") {
			return this.getEndGR(parameters.task);
		}
		return select unique TaskGR from this;
	}

	BeginGR getBeginGR(required Task task) {
		return select unique BeginGR from this;
	}

	EndGR getEndGR(required Task task) {
		return select unique EndGR from this;
	}

	GatewayGR getGatewayGR(required Gateway gateway) {
		return select unique GatewayGR from this;
		return null;
	}

	ActorGR getActorGR(required Actor actor) {
		return select unique ActorGR from this;
	}

	concept ProcessGR {
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE,exampleLabel="Shape");
		DiagramShape header with ShapeRole(metamodelElement=DIAGRAM_SHAPE3,exampleLabel="Shape",label=process.name);
		Process process with ConceptInstance(virtualModelInstance=processModel);
		@UI(
			@TextField(value="processName")
		)
		create::instantiateProcess(required ProcessType processType, required String processName) {
			process = new Process(parameters.processName,parameters.processType);
			shape = DIAGRAM::AddShape(container=diagram) in diagram;
			header = DIAGRAM::AddShape(container=diagram) in diagram;
			ProcessTypeGR processTypeGR = processTypeEditor.getProcessTypeGR(parameters.processType);
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
		}
		public void start() {
			process.startProcess();
		}
	}

	concept BeginGR {
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE4,exampleLabel="");
		Task task with ConceptInstance(virtualModelInstance=processModel);
		public delete() {
			delete shape;
			delete task;
		}
		create::representTask(required Task task) {
			task = parameters.task;
			shape = DIAGRAM::AddShape(container=container.getProcessGR(task.container).shape) in diagram;
			BeginGR beginTypeGR = processTypeEditor.getBeginGR(parameters.task.type);
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
		}
	}

	concept TaskGR {
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE5,exampleLabel="");
		Task task with ConceptInstance(virtualModelInstance=processModel);
		DiagramShape title with ShapeRole(metamodelElement=DIAGRAM_SHAPE6,exampleLabel="Task",label=task.name);
		DiagramShape performingActors with ShapeRole(metamodelElement=DIAGRAM_SHAPE7,exampleLabel="Actors",label=task.performingActorsLabel);
		DiagramShape status with ShapeRole(metamodelElement=DIAGRAM_SHAPE8,exampleLabel="Status",label=task.statusLabel);
		public delete() {
			delete shape;
			delete task;
		}
		create::representTask(required Task task) {
			task = parameters.task;
			shape = DIAGRAM::AddShape(container=container.getProcessGR(task.container).shape) in diagram;
			title = DIAGRAM::AddShape(container=container.getProcessGR(task.container).shape) in diagram;
			performingActors = DIAGRAM::AddShape(container=container.getProcessGR(task.container).shape) in diagram;
			status = DIAGRAM::AddShape(container=container.getProcessGR(task.container).shape) in diagram;
			BeginGR taskTypeGR = processTypeEditor.getTaskTypeGR(parameters.task.type);
			log "pour " + task + " taskTypeGR=" + taskTypeGR;
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
		}
		public void completeTask() {
			task.finishTask();
		}
	}

	concept EndGR {
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE9,exampleLabel="");
		ConceptInstance task with ConceptInstance(virtualModelInstance=processModel);
		public delete() {
			delete shape;
			delete task;
		}
		create::representTask(required Task task) {
			task = parameters.task;
			shape = DIAGRAM::AddShape(container=container.getProcessGR(task.container).shape) in diagram;
			EndGR endTypeGR = processTypeEditor.getEndGR(parameters.task.type);
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
		}
	}

	concept GatewayGR {
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE10,exampleLabel="");
		ConceptInstance gateway with ConceptInstance(virtualModelInstance=processModel);
		delete() {
			delete shape;
		}
		create::representGateway(required Gateway gateway, Process process) {
			gateway = parameters.gateway;
			shape = DIAGRAM::AddShape(container=container.getProcessGR(parameters.process).shape) in diagram;
			ShapeBasedGR gatewayGR = processTypeEditor.getGatewayGR(parameters.gateway);
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
		}
	}

	concept SequencingGR {
		DiagramConnector connector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR,exampleLabel="");
		ConceptInstance sequencing with ConceptInstance(virtualModelInstance=processModel);
		create::representSequencing(required Sequencing sequencing, Process process) {
			sequencing = parameters.sequencing;
			Task startTask = process.type.getTask(sequencing.in,process);
			Task endTask = process.type.getTask(sequencing.out,process);
			BeginGR startTaskGR = container.getTaskGR(startTask);
			BeginGR endTaskGR = container.getTaskGR(endTask);
			log "Start=" + startTaskGR;
			log "End=" + endTaskGR;
			connector = DIAGRAM::AddConnector(fromShape=startTaskGR.shape,toShape=endTaskGR.shape) in diagram;
		}
	}

	concept AndSplitConnectorsGR {
		DiagramConnector inConnector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR,exampleLabel="");
		ConceptInstance andSplit with ConceptInstance(virtualModelInstance=processModel);
		DiagramConnector outConnector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR,exampleLabel="");
		create::representAndSplit(required AndSplit andSplit, Process process) {
			andSplit = parameters.andSplit;
			Task startTask = process.type.getTask(andSplit.in,process);
			BeginGR startTaskGR = container.getTaskGR(startTask);
			GatewayGR gatewayGR = container.getGatewayGR(parameters.andSplit);
			inConnector = DIAGRAM::AddConnector(fromShape=startTaskGR.shape,toShape=gatewayGR.shape) in diagram;
			for (Object taskType : andSplit.out) {
				Task endTask = process.type.getTask(taskType,process);
				BeginGR endTaskGR = container.getTaskGR(endTask);
				outConnector = DIAGRAM::AddConnector(fromShape=gatewayGR.shape,toShape=endTaskGR.shape) in diagram;
			}
		}
	}

	concept AndJoinConnectorsGR {
		DiagramConnector inConnector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR,exampleLabel="");
		ConceptInstance andJoin with ConceptInstance(virtualModelInstance=processModel);
		DiagramConnector outConnector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR,exampleLabel="");
		create::representAndSplit(required AndJoin andJoin, Process process) {
			andJoin = parameters.andJoin;
			Task endTask = process.type.getTask(andJoin.out,process);
			BeginGR endTaskGR = container.getTaskGR(endTask);
			GatewayGR gatewayGR = container.getGatewayGR(parameters.andJoin);
			outConnector = DIAGRAM::AddConnector(fromShape=gatewayGR.shape,toShape=endTaskGR.shape) in diagram;
			for (Object taskType : andJoin.in) {
				Task startTask = process.type.getTask(taskType,process);
				BeginGR startTaskGR = container.getTaskGR(startTask);
				inConnector = DIAGRAM::AddConnector(fromShape=startTaskGR.shape,toShape=gatewayGR.shape) in diagram;
			}
		}
	}

	concept ActorGR {
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE2,exampleLabel="Actor",label=actor.name);
		ConceptInstance actor with ConceptInstance(virtualModelInstance=processModel);
		@UI(
			@TextField(value="name")
		)
		ActorGR dropActorGRAtTopLevel(required String name) with DropScheme() {
			shape = DIAGRAM::AddShape(container=topLevel) in diagram;
			actor = new Actor(parameters.name);
		}
		create::representActor(required Actor actor) {
			actor = parameters.actor;
			shape = DIAGRAM::AddShape(container=container.diagram) in diagram;
			ActorGR actorInProcessTypeGR = processTypeEditor.getActorGR(parameters.actor);
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
			DIAGRAM::GraphicalAction() in diagram;
		}
	}

	concept ActorAssignationGR {
		DiagramConnector connector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR2,exampleLabel="Connector28");
		ActorAssignationGR linkActorGRToTaskGR() with LinkScheme(fromType=ActorGR,toType=TaskGR) {
			connector = DIAGRAM::AddConnector(fromShape=fromTarget.shape,toShape=toTarget.shape) in diagram;
			toTarget.task.addToPerformingActor(fromTarget.actor);
		}
		create::representAssignation(required Actor actor, required Task task) {
			ActorGR actorGR = container.getActorGR(parameters.actor);
			BeginGR taskGR = container.getTaskGR(parameters.task);
			connector = DIAGRAM::AddConnector(fromShape=actorGR.shape,toShape=taskGR.shape) in diagram;
		}
	}
}
