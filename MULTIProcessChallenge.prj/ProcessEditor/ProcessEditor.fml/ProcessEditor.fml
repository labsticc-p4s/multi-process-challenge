namespace "http://www.openflexo.org/MULTIProcessChallenge" as MULTIPROCESSCHALLENGE;

use org.openflexo.technologyadapter.diagram.TypedDiagramModelSlot as DIAGRAM;
use org.openflexo.foundation.fml.rt.FMLRTVirtualModelInstanceModelSlot as FMLRT;

import org.openflexo.technologyadapter.diagram.model.DiagramShape;
import org.openflexo.technologyadapter.diagram.model.Diagram;
import org.openflexo.technologyadapter.diagram.model.DiagramConnector;

import [MULTIPROCESSCHALLENGE + "/MetaModel.fml"] as MetaModel;
import [MULTIPROCESSCHALLENGE + "/ProcessTypeEditor.fml"] as ProcessTypeEditor;

import [MULTIPROCESSCHALLENGE + "/Process"] as DIAGRAM_SPECIFICATION;
import [MULTIPROCESSCHALLENGE + "/Process/ExampleDiagram.diagram"] as EXAMPLE_DIAGRAM;
import [EXAMPLE_DIAGRAM:"SYL-29"] as DIAGRAM_SHAPE;
import [EXAMPLE_DIAGRAM:"SYL-23"] as DIAGRAM_SHAPE2;
import [EXAMPLE_DIAGRAM:"SYL-30"] as DIAGRAM_SHAPE3;
import [EXAMPLE_DIAGRAM:"SYL-2"] as DIAGRAM_SHAPE4;
import [EXAMPLE_DIAGRAM:"SYL-3"] as DIAGRAM_SHAPE5;
import [EXAMPLE_DIAGRAM:"SYL-32"] as DIAGRAM_SHAPE6;
import [EXAMPLE_DIAGRAM:"SYL-33"] as DIAGRAM_SHAPE7;
import [EXAMPLE_DIAGRAM:"SYL-34"] as DIAGRAM_SHAPE8;
import [EXAMPLE_DIAGRAM:"SYL-6"] as DIAGRAM_SHAPE9;
import [EXAMPLE_DIAGRAM:"SYL-4"] as DIAGRAM_SHAPE10;
import [EXAMPLE_DIAGRAM:"SYL-5"] as DIAGRAM_CONNECTOR;
import [EXAMPLE_DIAGRAM:"SYL-28"] as DIAGRAM_CONNECTOR2;
import [EXAMPLE_DIAGRAM:"SYL-29"] as DIAGRAM_SHAPE11;
import [EXAMPLE_DIAGRAM:"SYL-23"] as DIAGRAM_SHAPE12;
import [EXAMPLE_DIAGRAM:"SYL-30"] as DIAGRAM_SHAPE13;
import [EXAMPLE_DIAGRAM:"SYL-32"] as DIAGRAM_SHAPE14;
import [EXAMPLE_DIAGRAM:"SYL-33"] as DIAGRAM_SHAPE15;
import [EXAMPLE_DIAGRAM:"SYL-34"] as DIAGRAM_SHAPE16;
@URI("http://www.openflexo.org/MULTIProcessChallenge/ProcessEditor.fml")
@Version("0.1")
model ProcessEditor {
	
	MetaModel processModel with ModelInstance(isRequired=true);
	Process process with ConceptInstance(virtualModelInstance=processModel);
	ProcessTypeEditor processTypeEditor with ModelInstance(isRequired=true);
	
	Diagram diagram with TypedDiagram(
		diagramSpecification=DIAGRAM_SPECIFICATION,
		isRequired=true,
		paletteElementBindings={
			PaletteElementBinding:(call=new ActorInstanceGR::dropActorGRAtTopLevel(null), paletteElementId="http://www.openflexo.org/MULTIProcessChallenge/Process/Palette.palette#ActorGR")});

	create::init(required MetaModel processModel, required ProcessType processType, required String processName, required ProcessTypeEditor processTypeEditor) {
		log"Creating the process...";
		diagram = DIAGRAM::CreateDiagram(resourceName=parameters.processType.name + "_" + parameters.processName,resourceCenter=this.resourceCenter,relativePath="/Diagrams");
		processModel = parameters.processModel;
		processTypeEditor = parameters.processTypeEditor;
		ProcessGR newProcessGR = new ProcessGR::instantiateProcess(parameters.processType,parameters.processName);
		process = newProcessGR.process;
		log "Les tasks= " + newProcessGR.process.tasks;
		for (Task task : process.tasks) {
			log "Task=" + task;
			if (task.type.conceptType.name == "Begin") {
				new BeginEventGR::representTask(task);
				log "New begin";
			}
			else {
				if (task.type.conceptType.name == "End") {
					new EndEventGR::representTask(task);
					log "New end";
				}
				else {
					new TaskGR::representTask(task);
					log "New task";
				}
			}
		}
		for (Gateway gateway : process.type.gateways) {
			if (gateway.conceptType.name == "AndSplit" || gateway.conceptType.name == "AndJoin") {
				new GatewayGR::representGateway(gateway,process);
			}
		}
		for (Sequencing sequencing : process.type.sequencingList) {
			log "On cherche a representer la sequence " + sequencing;
			new SequencingGR::representSequencing(sequencing,process);
		}
		for (AndSplit andSplit : process.type.andSplitList) {
			new AndSplitConnectorsGR::representAndSplit(andSplit,process);
		}
		for (Actor actor : processModel.actorList) {
			new ActorInstanceGR::representActor(actor);
		}
		for (AndJoin andJoin : process.type.andJoinList) {
			new AndJoinConnectorsGR::representAndSplit(andJoin,process);
		}
		for (Task task : process.tasks) {
			for (Actor actor : task.performingActors) {
				new ActorAssignationGR::representAssignation(actor,task);
			}
		}
	}

	delete() {
	}

	ProcessGR getProcessGR(required Process process) {
		return select unique ProcessGR from this where (selected.process == parameters.process);
	}

	AbstractTaskGR getTaskGR(required Task task) {
		if (parameters.task.type.conceptType.name == "Begin") {
			return this.getBeginGR(parameters.task);
		}
		if (parameters.task.type.conceptType.name == "End") {
			return this.getEndGR(parameters.task);
		}
		return select unique TaskGR from this where (selected.task == parameters.task);
	}

	BeginEventGR getBeginGR(required Task task) {
		return select unique BeginEventGR from this where (selected.task == parameters.task);
	}

	EndEventGR getEndGR(required Task task) {
		return select unique EndEventGR from this where (selected.task == parameters.task);
	}

	GatewayGR getGatewayGR(required Gateway gateway) {
		return select unique GatewayGR from this where (selected.gateway == parameters.gateway);
		return null;
	}

	ActorInstanceGR getActorGR(required Actor actor) {
		return select unique ActorInstanceGR from this where (selected.actor == parameters.actor);
	}

	concept ProcessGR {
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE,exampleLabel="Shape");
		DiagramShape header with ShapeRole(metamodelElement=DIAGRAM_SHAPE3,exampleLabel="Shape",label=process.name);
		Process process with ConceptInstance(virtualModelInstance=processModel);
		@UI(
			@TextField(value="processName")
		)
		create::instantiateProcess(required ProcessType processType, required String processName) {
			log "instantiateProcess " + parameters.processType;
			log "processModel=" + processModel;
			process = processModel.new Process(parameters.processName,parameters.processType);
			shape = DIAGRAM::AddShape(container=diagram) in diagram;
			header = DIAGRAM::AddShape(container=shape) in diagram;
			ProcessTypeGR processTypeGR = processTypeEditor.getProcessTypeGR(parameters.processType);
			shape.graphicalRepresentation.x = processTypeGR.shape.graphicalRepresentation.x;
			shape.graphicalRepresentation.y = processTypeGR.shape.graphicalRepresentation.y;
			shape.graphicalRepresentation.width = processTypeGR.shape.graphicalRepresentation.width;
			shape.graphicalRepresentation.height = processTypeGR.shape.graphicalRepresentation.height;
		}
		public void start() {
			process.startProcess();
		}
	}

	concept BeginEventGR extends AbstractTaskGR {
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE4,exampleLabel="");
		Task task with ConceptInstance(virtualModelInstance=processModel);
		public delete() {
			delete shape;
			delete task;
		}
		create::representTask(required Task task) {
			task = parameters.task;
			shape = DIAGRAM::AddShape(container=container.getProcessGR(task.container).shape) in diagram;
			BeginGR beginTypeGR = processTypeEditor.getBeginGR((Begin)parameters.task.type);
			shape.graphicalRepresentation.x = beginTypeGR.shape.graphicalRepresentation.x;
			shape.graphicalRepresentation.y = beginTypeGR.shape.graphicalRepresentation.y;
			shape.graphicalRepresentation.width = beginTypeGR.shape.graphicalRepresentation.width;
			shape.graphicalRepresentation.height = beginTypeGR.shape.graphicalRepresentation.height;
		}
	}

	public abstract concept AbstractTaskGR {
		abstract DiagramShape shape;
	}

	concept TaskGR extends AbstractTaskGR {
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE5,exampleLabel="",transparency=(task.isActive || task.completed ? 1.0 : (task.isStartable() ? 0.5 : 0.2)));
		Task task with ConceptInstance(virtualModelInstance=processModel);
		DiagramShape title with ShapeRole(metamodelElement=DIAGRAM_SHAPE6,exampleLabel="Task",label=task.name);
		DiagramShape performingActors with ShapeRole(metamodelElement=DIAGRAM_SHAPE7,exampleLabel="Actors",label=task.performingActorsLabel);
		DiagramShape status with ShapeRole(metamodelElement=DIAGRAM_SHAPE8,exampleLabel="Status",label=task.statusLabel);
		public delete() {
			delete shape;
			delete task;
		}
		create::representTask(required Task task) {
			task = parameters.task;
			shape = DIAGRAM::AddShape(container=container.getProcessGR(task.container).shape) in diagram;
			title = DIAGRAM::AddShape(container=shape) in diagram;
			performingActors = DIAGRAM::AddShape(container=shape) in diagram;
			status = DIAGRAM::AddShape(container=shape) in diagram;
			ShapeBasedGR taskTypeGR = processTypeEditor.getTaskTypeGR(parameters.task.type);
			//log "Pour la Task " + task + " x=" + taskTypeGR.shape.graphicalRepresentation.x + " y=" + taskTypeGR.shape.graphicalRepresentation.y + " width=" + taskTypeGR.shape.graphicalRepresentation.width + " height=" + taskTypeGR.shape.graphicalRepresentation.height;
			shape.graphicalRepresentation.x = taskTypeGR.shape.graphicalRepresentation.x;
			shape.graphicalRepresentation.y = taskTypeGR.shape.graphicalRepresentation.y;
			shape.graphicalRepresentation.width = taskTypeGR.shape.graphicalRepresentation.width;
			shape.graphicalRepresentation.height = taskTypeGR.shape.graphicalRepresentation.height + 20;
		}
		public void completeTask() {
			task.finishTask();
		}
	}

	concept EndEventGR extends AbstractTaskGR {
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE9,exampleLabel="");
		Task task with ConceptInstance(virtualModelInstance=processModel);
		public delete() {
			delete shape;
			delete task;
		}
		create::representTask(required Task task) {
			task = parameters.task;
			shape = DIAGRAM::AddShape(container=container.getProcessGR(task.container).shape) in diagram;
			EndGR endTypeGR = processTypeEditor.getEndGR((End)parameters.task.type);
			shape.graphicalRepresentation.x = endTypeGR.shape.graphicalRepresentation.x;
			shape.graphicalRepresentation.y = endTypeGR.shape.graphicalRepresentation.y;
			shape.graphicalRepresentation.width = endTypeGR.shape.graphicalRepresentation.width;
			shape.graphicalRepresentation.height = endTypeGR.shape.graphicalRepresentation.height;
		}
	}

	concept GatewayGR {
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE10,exampleLabel="");
		Gateway gateway with ConceptInstance(virtualModelInstance=processModel);
		delete() {
			delete shape;
		}
		create::representGateway(required Gateway gateway, Process process) {
			gateway = parameters.gateway;
			shape = DIAGRAM::AddShape(container=container.getProcessGR(parameters.process).shape) in diagram;
			ShapeBasedGR gatewayGR = processTypeEditor.getGatewayGR(parameters.gateway);
			shape.graphicalRepresentation.x = gatewayGR.shape.graphicalRepresentation.x;
			shape.graphicalRepresentation.y = gatewayGR.shape.graphicalRepresentation.y;
			shape.graphicalRepresentation.width = gatewayGR.shape.graphicalRepresentation.width;
			shape.graphicalRepresentation.height = gatewayGR.shape.graphicalRepresentation.height;
		}
	}

	concept SequencingGR {
		DiagramConnector connector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR,exampleLabel="");
		Sequencing sequencing with ConceptInstance(virtualModelInstance=processModel);
		create::representSequencing(required Sequencing sequencing, Process process) {
			sequencing = parameters.sequencing;
			Task startTask = process.type.getTask(sequencing.inTaskType,process);
			Task endTask = process.type.getTask(sequencing.outTaskType,process);
			AbstractTaskGR startTaskGR = container.getTaskGR(startTask);
			AbstractTaskGR endTaskGR = container.getTaskGR(endTask);
			log "Start=" + startTaskGR;
			log "End=" + endTaskGR;
			connector = DIAGRAM::AddConnector(fromShape=startTaskGR.shape,toShape=endTaskGR.shape) in diagram;
		}
	}

	concept AndSplitConnectorsGR {
		DiagramConnector inConnector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR,exampleLabel="");
		AndSplit andSplit with ConceptInstance(virtualModelInstance=processModel);
		DiagramConnector outConnector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR,exampleLabel="");
		create::representAndSplit(required AndSplit andSplit, Process process) {
			andSplit = parameters.andSplit;
			Task startTask = process.type.getTask(andSplit.inTaskType,process);
			AbstractTaskGR startTaskGR = container.getTaskGR(startTask);
			GatewayGR gatewayGR = container.getGatewayGR(parameters.andSplit);
			inConnector = DIAGRAM::AddConnector(fromShape=startTaskGR.shape,toShape=gatewayGR.shape) in diagram;
			for (TaskType taskType : andSplit.outTaskTypes) {
				Task endTask = process.type.getTask(taskType,process);
				AbstractTaskGR endTaskGR = container.getTaskGR(endTask);
				outConnector = DIAGRAM::AddConnector(fromShape=gatewayGR.shape,toShape=endTaskGR.shape) in diagram;
			}
		}
	}

	concept AndJoinConnectorsGR {
		DiagramConnector inConnector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR,exampleLabel="");
		AndJoin andJoin with ConceptInstance(virtualModelInstance=processModel);
		DiagramConnector outConnector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR,exampleLabel="");
		create::representAndSplit(required AndJoin andJoin, Process process) {
			andJoin = parameters.andJoin;
			Task endTask = process.type.getTask(andJoin.outTaskType,process);
			AbstractTaskGR endTaskGR = container.getTaskGR(endTask);
			GatewayGR gatewayGR = container.getGatewayGR(parameters.andJoin);
			outConnector = DIAGRAM::AddConnector(fromShape=gatewayGR.shape,toShape=endTaskGR.shape) in diagram;
			for (TaskType taskType : andJoin.inTaskTypes) {
				Task startTask = process.type.getTask(taskType,process);
				AbstractTaskGR startTaskGR = container.getTaskGR(startTask);
				inConnector = DIAGRAM::AddConnector(fromShape=startTaskGR.shape,toShape=gatewayGR.shape) in diagram;
			}
		}
	}

	concept ActorInstanceGR {
		
		DiagramShape shape with ShapeRole(metamodelElement=DIAGRAM_SHAPE2,exampleLabel="Actor",label=actor.name);
		Actor actor with ConceptInstance(virtualModelInstance=processModel);

		ActorInstanceGR dropActorGRAtTopLevel(required String name) with DropScheme(targetType=ProcessEditor) {
			shape = DIAGRAM::AddShape(container=topLevel) in diagram;
			actor = new Actor(parameters.name);
		}
		create::representActor(required Actor actor) {
			actor = parameters.actor;
			shape = DIAGRAM::AddShape(container=container.diagram) in diagram;
			ActorGR actorInProcessTypeGR = processTypeEditor.getActorGR(parameters.actor);
			shape.graphicalRepresentation.x = actorInProcessTypeGR.shape.graphicalRepresentation.x;
			shape.graphicalRepresentation.y = actorInProcessTypeGR.shape.graphicalRepresentation.y;
			shape.graphicalRepresentation.width = actorInProcessTypeGR.shape.graphicalRepresentation.width;
			shape.graphicalRepresentation.height = actorInProcessTypeGR.shape.graphicalRepresentation.height;
		}

		public ActorType addActorType(required ActorType actorType) {
			actor.addActorType(parameters.actorType);
			return parameters.actorType;
		}
	}

	concept ActorAssignationGR {
		DiagramConnector connector with ConnectorRole(metamodelElement=DIAGRAM_CONNECTOR2,exampleLabel="Connector28");
		ActorAssignationGR linkActorGRToTaskGR() with LinkScheme(fromType=ActorInstanceGR,toType=TaskGR) {
			log "Assigning " + fromTarget.actor + " to " + toTarget.task;
			if (toTarget.task.isAuthorizedActor(fromTarget.actor)) {
				connector = DIAGRAM::AddConnector(fromShape=fromTarget.shape,toShape=toTarget.shape) in diagram;
				toTarget.task.addToPerformingActors(fromTarget.actor);
			}
			else {
				log "This actor is not authorized";
			}
		}
		create::representAssignation(required Actor actor, required Task task) {
			ActorInstanceGR actorInstanceGR = container.getActorGR(parameters.actor);
			AbstractTaskGR taskGR = container.getTaskGR(parameters.task);
			connector = DIAGRAM::AddConnector(fromShape=actorInstanceGR.shape,toShape=taskGR.shape) in diagram;
		}
	}
}
