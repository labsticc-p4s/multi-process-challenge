%Model Presentation: detailed  presentation of a model, including justifications for design decisions

The presentation of our solution to the \mpc follows a systematic methodology where modeling choices are introduced step by step, as the requirements are stated. Satisfaction of requirements are explained throughout this presentation.

%\todo[inline]{phrase d'intro pour expliquer que les req étaient couverts au fur et à mesure (côté systématique)}

Figure \ref{fig:MultilevelArchitecture} shows the overview of the multivel architecture designed to capture the two use cases described in the Process Challenge.

% Expliquer que le use case XSure ne nécessitait pas l'extension de metamodèle requise pour le usecase Acme Software Developement Process

\subsection{Base metamodel for the Process Challenge}

\begin{figure*}
 \centering
    % \includegraphics[width=1.0 \columnwidth]{Figures/Metamodel.pdf}
    \includegraphics[width=1.0 \textwidth]{Figures/Metamodel.pdf}
     \caption{Process management base metamodel}
    \label{fig:BaseMetamodel}
\end{figure*}

In this section, we present and illustrate the base metamodel presented in figure \ref{fig:BaseMetamodel} with \textit{XSure} insurance domain use case, whose a partial description was provided in the challenge description. Note that the capture of the requirements \textbf{P1} to \textbf{P19} in the context of XSure insurance domain are straightforward implementable while instantiating \textit{XSure model}, as an instance of base metamodel (the left side of figure \ref{fig:MultilevelArchitecture}).

Figure \ref{fig:BaseMetamodel} represents this base metamodel with a UML-like formalism, well adapted to represent object-oriented FML concepts and their instances. Base conceptual element is called a \textit{FlexoConcept} in FML language, and is similar to the concept of class in object-oriented modeling. We use the UML representation of class to represent a \textit{FlexoConcept}, while cardinalities are shown using the UML-like classical rules.

Our proposition relies on ontologic instantiation as presented in figure \ref{fig:LinguisticAndOntologicInstantiation}, with a common root concept \textit{ModelingElement}. Two types of ontological instantiation are needed to meet the requirements of the challenge. One provides that some instances conform to only one type (\textit{Process} and \textit{Task} do respectively conform to one \textit{ProcessType} and \textit{TaskType}) while some entities define their conformity to several types (\textit{Actor} and \textit{Artifact} do respectively conform to several \textit{ActorType} and \textit{ArtifactType}). This instantiation is reified with the relations \textit{type} and \textit{types} between \textit{Type}, \textit{Instance} and \textit{MultiInstance} concepts.  

\subsubsection{Process type definition}

We first present the process definition part of base metamodel, located left of figure \ref{fig:BaseMetamodel}.

% Illustrer avec des instances de XSure

\textit{ProcessType} is defined as a specialization of \textit{Type} \texttt{FlexoConcept}, and references a collection of \textit{TaskType} through the composition relation \textit{taskTypes} with (0..*) cardinality (\textbf{P1}). A \textit{TaskType} is embedded in a \textit{ProcessType} and inherits from it context. To illustrate this in \textit{XSure} insurance domain use case, \textit{XSure model} defines \textit{Claim Handling}, instance of \textit{ProcessType}, and \textit{Receive Claim}, \textit{Asses Claim} and \textit{Pay premium}, instances of \textit{TaskType}.

\textit{ProcessType} also references a collection of gateways, reified with the \textit{Gateway} concept hierarchy. \textit{Gateway} is defined as a specialization of \textit{Type} and is specialized with \textit{Sequencing}, \textit{AndSplit}, \textit{AndJoin}, \textit{OrSplit} and \textit{OrJoin} concepts (\textbf{P2}). Depending of its type, a \textit{Gateway} defines one or more inputs and one or more outputs, depending of its underlying execution semantics. A \textit{ProcessType} additionally exposes unique initial \textit{TaskType} and a collection of final \textit{TaskType} with both attributes \textit{initialTaskType} (single cardinality) and \textit{finalTaskType} (cardinality 0..*) (\textbf{P3}). TaskType exposes a creator attribute as an association relation to \textit{Actor} concept (\textbf{P4}), which is in the same conceptual level. 

Following listing shows an excerpt of FML code modeling some core concepts of process modeling base metamodel. 

\begin{lstlisting}
model MetaModel {

  concept ModelingElement { ... }
  
  concept Type extends ModelingElement { ... }
  
  concept ProcessType extends Type {
    TaskType[0..*] taskTypes;
    TaskType initialTaskType;
    TaskType[0..*] finalTaskTypes;
    Gateway[0..*] gateways;
        
    concept TaskType extends Type {
      Actor creator;
      Actor[0..*] allowedActors;
      ActorType[0..*] allowedActorTypes;
      ...
    }
        
    abstract concept Gateway extends Type {
      abstract void execute(Process process);
      ...
    }
        
    concept Sequencing extends Gateway {
      TaskType in;
      TaskType out;
    }
    
    // Other core concepts
  }
}    
\end{lstlisting}


\textit{ActorType} is defined as a sub-concept of \textit{Type} and the \textit{allowedActorTypes} relation to \textit{ActorType} which is defined in \textit{TaskType} (with 0..* cardinality) captures \textbf{P5} requirement. Requirement \textbf{P6} is symmetrically satisfied with \textit{allowedActors} relation to \textit{Actor} also defined in \textit{TaskType} (with same 0..* cardinality). Same modeling pattern applies for \textit{ArtefactType} defined as a sub-concept of \textit{Type}, and both relations \textit{usedArtifactTypes} and \textit{producedArtifactTypes} defined in \textit{TaskType} (\textbf{P7}). \textit{TaskType} additionnaly exposes an \textit{expectedDuration} attribute (expressed in number of days), satisfying \textbf{P8}. 

Actor concept defines a boolean attribute called \textit{isSenior}, while \textit{TaskType} defines an additional \textit{isCritical} boolean attribute, indicating that some instance of \textit{TaskType} are flagged as critical and must be performed by senior actors. To fullfill \textbf{P9} requirement, a supplementary constraint is required for \textit{TaskType} and is captured through this invariant expressed in FML language:

\begin{lstlisting}
forEach (actor : allowedActors) {
    assert !isCritical | actor.isSenior
}
\end{lstlisting}

This invariant should be completed with additional constraints defined in \textit{Task} \textit{FlexoConcept}, which apply to performing actors actually assigned to enacted tasks. 

\todo{Gérer également la fin de P9, non traité pour le moment: artifact they produced must be associated with a validation task}

\subsubsection{Process enactment}
\label{sec:ProcessEnactment}
We now present the process enactment part of base metamodel, located right of figure \ref{fig:BaseMetamodel}. All concepts defined in this subsection are either specialization of \textit{Instance} concept (if they are associated with exactly one \textit{Type}) or \textit{MultiInstance} concept (for those which have several types).

\textit{Process} represents an enacted \textit{ProcessType}, as defined in previous subsection (\textbf{P10}). FML defines behavioural features (operations in object-oriented modelling), called \texttt{FlexoBehaviour}. \textit{ProcessType} defines following behaviour \texttt{newProcess(String)}, taking a \texttt{String} argument (the name of the process to enact):

\begin{lstlisting}
public Process newProcess(String name) {    
  Process newProcess = new Process(name,this);  
  for (taskType : taskTypes) {      
    Task newTask = taskType.newTask(newProcess.name+"-"+taskType.name),newProcess);        
  }      
  return newProcess;    
}    
\end{lstlisting}

This scheme allows to rely on FML dynamic binding mechanism to delegate to types the responsability for instances creation. An instance of \textit{Process} references a unique \textit{ProcessType} trough the specialized \textit{/type} relation. Each instance of \textit{TaskType} is ontologically instantiated with a \textit{Task} (\textbf{P11}), using the same pattern where \textit{TaskType} has the responsability to manage this ontological instantiation. A \textit{Task} references its unique \textit{TaskType}, and defines a \textit{begin date} and an \textit{end date} as basic attributes of the concept (\textbf{P12}).

Same pattern applies for artifacts used and produced with relations \textit{usedArtifacts}, \textit{producedArtifacts} and \textit{performingActors} defined in \textit{Task} concept (\textbf{P13}). An instance of \textit{Artifact}, defined as a specialization of \textit{MultiInstance} concept, references a set of \textit{ArtifactType} through the specialized \textit{/types} relation (\textbf{P14} and \textbf{P16}). Likewise, concept \textit{Actor} is defined as a specialization of \textit{MultiInstance} concept and references a set of \textit{ActorType} through the specialized \textit{/types} relation (\textbf{P15}).

Semantics is unclear relatively to instantiation policy for artifacts. We assume that task execution implies that for each used and produced \textit{artifact type} defined in related \textit{task type}, it exists at least one \textit{artifact} declaring required ontologic instantiation (through \textit{type} relation). Following excerpt of FML code shows partial implementation of this. Same patterns applied for produced artifacts.

\begin{lstlisting}
concept Task extends Instance {
  ...
  boolean declaresRequiredUsedArtifacts() {
    for (artifactType : type.usedArtifactType) {
      boolean found = false;
      for (artifact : usedArtifacts) {
        if (artifact.isOfType(artifactType))
          found = true;
      }
      if (!found) return false;
    }
    return true;
  }
  ...
}    
\end{lstlisting}

Authorization for an actor to perform a task (\textbf{P17}) is captured either through the relations \textit{allowedActors} and \textit{allowedActorTypes} defined in \textit{TaskType}. This mechanism is completed by following behaviours \textit{isAuthorizedActor(Actor)}, \textit{isValidActor(Actor)} and \textit{isValidActorType(ActorType)} defined in \textit{TaskType} : 

\begin{lstlisting}
concept TaskType extends Type {
 ...
 // Check that an Actor is authorized to perform a task, using allowed Actor and ActorTypes
  boolean isAuthorizedActor(Actor actor) {      
    for (actType : allowedActorTypes) {        
      if (actor.hasActorType(actType))         
        return this.isValidActorType(actType);          
    }        
    for (act : allowedActors) {        
      if (actor == act)         
        return this.isValidActor(actor);
    }
    return false;
  }
  
 // Check that an Actor may perform this TaskType (override when required)
  boolean isValidActor(Actor actor) {
    return true;
  }

 // Check that an ActorType may perform this TaskType (override when required)
  boolean isValidActorType(ActorType actorType) {
    return true;
  }
  ...
}
\end{lstlisting}

\textit{Task} concept basically delegates this authorization to its related \textit{TaskType}, as shown in following FML excerpt:

\begin{lstlisting}
concept Task extends Instance {
  ...
  boolean isAuthorizedActor(Actor actor) {      
    return type.isAuthorizedActor(actor);      
  }
  ...
}
\end{lstlisting}

Enforcing those constraints is finally performed by the definition of this invariant in \textit{Task} concept:

\begin{lstlisting}
forEach (actor : performingActors) {
  assert isAuthorizedActor(actor);
}
\end{lstlisting}

Default behaviour states that all actors and actor types are valid for all task types. This modelling scheme offers many extension points, by the redefinition of one or some behaviours in inherited concepts (although none were required in the context of XSure insurance use case).

Actor types specialization is captured by the \textit{parentActorTypes} relation defined in \textit{ActorType} (\textbf{P18}). This is completed by both the definition of \textit{hasActorType(ActorType)} behaviour in \textit{Actor} concept and recursive behaviour \textit{isOrSpecializes(ActorType)} in \textit{ActorType}:

\begin{lstlisting}
concept ActorType extends Type {
  ActorType[0..*] parentActorTypes;
  ...
  boolean isOrSpecializes(ActorType actorType) {    
    if (actorType == this)   
      return true;      
    for (p : parentActorTypes) {      
      if (p.isOrSpecializes(actorType)
        return true;
    }
    return false;
  }
  ...
}

concept Actor extends MultiInstance {
  ...
  boolean hasActorType(ActorType actType) {      
    for (type : types) {
      if (type.isOrSpecializes(actType))
        return true;
    }
    return false;
  }     
  ...
}
\end{lstlisting}

All concepts inherits from \textit{ModelingElement}, which defines a \textit{lastUpdated} attribute with \textit{Date} type, and thus satisfies \textbf{P19} requirement. 

\subsection{The Acme software development process}
\label{sec:AcmeSoftwareDevelopmentProcess}

The challenge describes in a second part a Software engineering process for a fictional Acme company. Base metamodel as described in previous section is too generic to capture all domain-specific aspects of this use case. We choose to complete the architectual hierarchy with a specific metamodel, specific to Acme software development process, as shown in figure \ref{fig:AcmeArchitecture}. \textit{Acme metamodel} inherits and specializes base metamodel, and \textit{Acme model} is defined as an instance of \textit{Acme metamodel}. Any instance of Acme model is either an instance of a concept defined in base metamodel, or a concept defined in specialized Acme metamodel, which may or not inherit from a concept defined in base metamodel.
% FML follows a classical object-oriented semantics. ???

\begin{figure}
 \centering
    \includegraphics[width=1.0 \columnwidth]{Figures/AcmeArchitecture.pdf}
     \caption{Acme software development process architecture}
    \label{fig:AcmeArchitecture}
\end{figure}

\begin{figure*}
 \centering
     \includegraphics[width=1.0 \textwidth]{Figures/AcmeFullArchitecture.pdf}
     \caption{Acme software development process architecture}
    \label{fig:AcmeFullArchitecture}
\end{figure*}

\todo{Augmenter la taille des fontes de la figure \ref{fig:AcmeFullArchitecture}}

Figure \ref{fig:AcmeFullArchitecture} shows the full architecture capturing Acme software development process, with an instance of enacted \textit{Software Engineering Process}, and highlights all conceptual levels. Acme metamodel enriches base metamodel by offering specializing concepts: \textit{SETaskType} extending \textit{TaskType}, a more specialized concept \textit{CodingTaskType} extending \textit{SETaskType}, \textit{SEArtifactType} extending \textit{ArtifactType}, a more specialized concept \textit{CodeArtifactType} extending \textit{SEArtifactType}. Acme metamodel also defines task type \textit{Coding} as a specialized concept of \textit{Task}, and provides concept \textit{Developer} extending \textit{ActorType}. This metamodel is completed with \textit{ProgrammingLanguage} concept, defined as an enumeration (\textit{Java}, \textit{C}, \textit{COBOL}). All instances required to capture challenge use case are still defined in final Acme model itself instance of Acme metamodel. Instances are represented with rounded boxes and linguistic instantiation are represented with dashed connectors.

Figure \ref{fig:AcmeSoftwareDevelopmentProcess} shows a screen-capture from the tooling developed in the context of the challenge, and presents the \textit{Software Development Process} for Acme company. 

\begin{figure}
 \centering
    \includegraphics[width=1.0 \columnwidth]{Figures/SoftwareEngineeringProcessCroped.pdf}
     \caption{Acme software development process}
    \label{fig:AcmeSoftwareDevelopmentProcess}
\end{figure}

\todo{Supprimer ombres et dégradés de la figure \ref{fig:AcmeSoftwareDevelopmentProcess}, et faire en sorte qu'elle soit plus haute et moins large}

\textit{"Requirements analysis"} is defined as an instance of \textit{SETaskType}, \textit{Analyst} as an instance of \textit{ActorType} and \textit{Requirement specifications} as an instance of \textit{SEArtifactType}. \textit{"Requirements analysis"} instance defines property values \textit{producedArtifactTypes=\{Requirement specifications\}} and \textit{allowedActorTypes=\{Analyst\}} (\textbf{S1}). In the same way, \textit{"Test case design"} is defined as an instance of \textit{SETaskType}, marked as critical with property value \textit{isCritical=\{true\}}, and bound to \textit{Analyst} with \textit{allowedActorTypes} relation. \textit{"Test case design"} produces \textit{"Test cases"} defined as an instance of \textit{SETaskType}. The latter is used in "Test design review" (\textit{producedArtifactTypes} relation) (\textbf{S1} and \textbf{S13}, satisfied with \textbf{P9}). 

The capture of \textbf{S3} requirement is performed while defining \textit{Coding} as an instance of concept \textit{CodingTaskType} extending \textit{SETaskType} and defining a relation \textit{languages} to \textit{ProgrammingLanguage} with 1..* cardinality. \textit{newTask(String)} behaviour overrides generic implementation while instantiating a \textit{Coding} concept, specializing \textit{SEArtifact}, as shown in following excerpt of FML code:

\begin{lstlisting}
concept CodingTaskType extends SETaskType {
  ProgrammingLanguage[1..*] languages;
  ...
  public Coding newTask(String name) { 
    return new Coding(name,this); 
  }
}    
\end{lstlisting}

\textit{Code} concept extends \textit{SEArtifact}, and defines a relation \textit{language} to \textit{ProgrammingLanguage} with single cardinality (\textbf{S4}). \textbf{S5} is more ambigous as task type \textit{Coding} defines one or more programming languages but produces code which is expressed in one language only. This requirement is captured through the redefinition of \textit{declaresRequiredProducedArtifacts()} where programming language should also match. \noteSylvain{Pas la place pour mettre le code, non nécessaire si ?} \textbf{S6} is guaranteed though the \textit{language} relation defined in \textit{Code} and following invariant declared in \textit{Code}:  

\begin{lstlisting}
forEach (artifactType : types) {
  assert !(artifactType instanceof CodeArtifactType) | artifactType.doesImplement(languages)
}
\end{lstlisting}

\textit{Ann Smith} is the only one allowed to perform coding in COBOL (\textbf{S7}). This is implemented through the redefinition of \textit{newTask(String)} in \textit{CodingTaskType}:

\begin{lstlisting}
concept CodingTaskType extends SETaskType {
  ...
  public Coding newTask(String name) {
    Coding returned = new Coding(name,this); 
    if (languages.contains(ProgrammingLanguage.COBOL))
      returned.addToPerformingActors(getActor("Ann Smith"));
    return returned;
  }
}    
\end{lstlisting}

\textbf{S8} requirement is simply captured with the definition of \textit{Testing} instance of \textit{SETaskType}, \textit{Tester} instance of \textit{ActorType}, and \textit{Test report} instance of \textit{ArtifactType}.

\todo[inline]{requirement S9 non couvert pour le moment: compléter}


All software engineering artifacts defined in the context of Acme Software Engineering Process (figure \ref{fig:AcmeSoftwareDevelopmentProcess}) are all instances of \textit{SEArtifact} which defines both attributes \textit{responsible} (an \textit{Actor} instance), and \textit{versionNumber} (an \textit{integer} value), and thus fulfills \textbf{S10}. \textit{Bob Brown} is declared as an instance of \textit{Actor}, and references \textit{Analyst} and \textit{Tester} (\textit{ActorType} instances). He is also referenced by all instances of \textit{SETaskType} as the creator for related task types (\textbf{S11}).

\textbf{S12} is somehow ambigous as it implies an implicit semantics regarding underlying business logic of process execution. We assume that all tasks may define an expected duration, which might be checked during process execution. This can be modelled through the addition of \textit{expectedDuration} attribute in \textit{TaskType}. Alternatively, this can be modelled through the definition of \textit{SETesting} concept, as a specialization of \textit{SETaskType}, and the instantiation of \textit{Testing} as an instance of \textit{SETesting}. The business logic expressed by \textbf{S12} requirement should be redefined in \textit{SETesting}.

\textbf{S13} requirement has been previously partially fulfilled. This must be completed with...

\todo[inline]{requirement S13 pas complètement couvert : compléter}

\subsection{Openflexo tooling}

Our solution is fully implemented within Openflexo tool. Both usecases have been modelled in the interactive design environment and are executable by the FML execution engine.

\todo[inline]{mettre ici le lien vers la page web qui montre la démo}

\todo[inline]{Ici: un paragraphe qui décrit l'exécution, l'activation et la finalisation des taches, la business logic des gateways, etc...}

We took advantage of model federation and the availability of diagramming features though the \textit{Diagramming TA} to implement two interactive graphical tools built on top of conceptual levels detailed in previous section. A first tool offers a graphical edition of a Process type, while the second tool offers enactment feature (the instantiation of a process from its process type), the ability within an enacted process to assign tasks to some actors, and the execution of this process with a graphical visualization.

\begin{figure*}
 \centering
     \includegraphics[width=0.9 \textwidth]{Figures/ToolingArchitecture.pdf}
     \caption{Tooling architecture}
    \label{fig:ToolingArchitecture}
\end{figure*}

Figure \ref{fig:ToolingArchitecture} shows the architecture of these two tools. Left of figure presents \textit{process type graphical editor}. \textit{ProcessTypeEditor} is implemented as a \textit{VirtualModel} declaring two model slots (represented with bold circles). The first model slot references an instance of Acme metamodel, while the second model slot references an instance of diagram, conforms to the \textit{ProcessType diagram specification} (a diagram "metamodel" which defines and specify structure and graphical representations for edited items). While executed, this tool manages a graphical view for an instance of Acme metamodel (the \textit{Acme model}) and a specific \textit{ProcessType} instance. This tools allows to represent and edit a \textit{ProcessType}. One particular point should be noted regarding the highly reflective nature of FML and associated tooling : when drag and drop interactor is applied for a new item, the tool allows to choose the concept type to be instantiated (when a \textit{TaskType} is created for example, the user must choose the sub-concept of \textit{TaskType} to be selected - in Acme use case it can be \textit{SETaskTask} or \textit{CodingTaskType} or default value \textit{TaskType}). 

The other tool, an \textit{enacted process editor}, provides process edition and tasks assignations through a graphical visualization displaying process being executed. This tool is represented one the right side of the figure \ref{fig:ToolingArchitecture}. It follows the same architecture pattern as explicited for the \textit{process type graphical editor}, with two model slots referencing both the model and a diagram. Process enactment is operated from a \textit{ProcessType}, and must be defined using a name identifying the newly instantiated process. All tasks are created from their \textit{TaskType} definition, and required assignments applies (if for example "Coding" \textit{TaskType} defines COBOL as output programming language, related task is automatically assigned to "Ann Smith"). All tasks get a status (\textit{Not startable} - when not assigned or when required input artifacts are not available - , \textit{Startable}, \textit{Started}, \textit{Completable}, \textit{Completed}), as well as a set of performing actors, a begin and end date, and used and produced artifacts. This tool also manages creation of artifacts, whose semantics follows rules defined in section \ref{sec:ProcessEnactment} (\textbf{P13}).

% Expliquer l'outillage construit et comment il marche


